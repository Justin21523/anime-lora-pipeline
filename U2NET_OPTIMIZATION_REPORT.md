# U2Net 參數優化測試報告

**測試日期**: 2025-10-30
**測試圖片**: 10 張 Yokai Watch frames
**測試配置**: 8 種參數組合
**測試環境**: CUDA (GPU)

---

## 📊 測試結果總結

### 整體性能排名

| 排名 | 配置 | 平均覆蓋率 | 平均邊界框 | 平均時間 | 推薦度 |
|------|------|------------|------------|----------|--------|
| 🥇 1 | **激進版本** | **22.9%** | **38.9%** | 0.031s | ⭐⭐⭐⭐⭐ |
| 🥈 2 | **擴張版本** | **21.5%** | 36.8% | 0.030s | ⭐⭐⭐⭐ |
| 🥉 3 | 平滑優先 | 20.5% | 36.1% | 0.033s | ⭐⭐⭐ |
| 4 | 強化邊緣 | 20.5% | 36.8% | 0.030s | ⭐⭐⭐ |
| 5 | **基礎版本** (當前) | 20.5% | 36.8% | 0.067s | ⭐⭐⭐ |
| 6 | Alpha Matting | 20.5% | 36.8% | 0.028s | ⭐⭐⭐ |
| 7 | 保守版本 | 20.3% | 35.5% | 0.039s | ⭐⭐ |
| 8 | 精細模式 | 20.3% | 36.2% | 0.033s | ⭐⭐ |

---

## 🎯 關鍵發現

### 1. 最佳配置: 激進版本 ⭐⭐⭐⭐⭐

**提升效果**:
- ✅ 覆蓋率提升: **20.5% → 22.9%** (+2.4%)
- ✅ 邊界框提升: **36.8% → 38.9%** (+2.1%)
- ✅ 速度提升: **0.067s → 0.031s** (2x faster)

**配置參數**:
```python
{
    "morphology": True,
    "kernel_size": 3,          # 小核心 - 保留細節
    "close": True,
    "close_iter": 5,           # 強力填充 - 連接斷裂部分
    "open": False,             # 不做 open - 保留所有區域
    "blur": True,
    "blur_size": 3,            # 小模糊 - 平滑但不過度
    "threshold": 100,          # 低閾值 - 包含更多區域
    "dilate": True,
    "dilate_size": 7,          # 大擴張 - 獲得完整輪廓
    "dilate_iter": 3           # 多次擴張
}
```

**適用場景**:
- ✅ 需要獲得**完整角色輪廓**
- ✅ 允許包含**部分周邊區域**
- ✅ 優先**完整性**而非精確度

---

### 2. 次優配置: 擴張版本 ⭐⭐⭐⭐

**提升效果**:
- ✅ 覆蓋率提升: **20.5% → 21.5%** (+1.0%)
- ✅ 速度提升: **0.067s → 0.030s** (2x faster)

**配置參數**:
```python
{
    "morphology": True,
    "kernel_size": 5,          # 中等核心
    "close": True,
    "close_iter": 2,           # 中等填充
    "open": True,
    "open_iter": 1,            # 輕度清理
    "blur": True,
    "blur_size": 5,            # 中等模糊
    "threshold": 127,          # 標準閾值
    "dilate": True,
    "dilate_size": 5,          # 中等擴張
    "dilate_iter": 2           # 兩次擴張
}
```

**適用場景**:
- ✅ 平衡**完整性與精確度**
- ✅ 適合大多數角色類型
- ✅ 穩定可靠的選擇

---

### 3. 基礎版本的問題

**問題發現**:
- ⚠️ 速度慢: 0.067s (其他配置 ~0.030s)
- ⚠️ 覆蓋率中等: 20.5%
- ⚠️ 沒有針對性優化

**結論**: 可以被「激進版本」或「擴張版本」完全取代

---

## 📈 逐配置詳細分析

### 激進版本 (推薦)

**優勢**:
1. ✅ **最高覆蓋率** 22.9%
2. ✅ **最大邊界框** 38.9%
3. ✅ **速度快** 0.031s
4. ✅ 在困難案例中表現優異

**典型案例**:
```
scene0065: 43.7% (vs 基礎 40.0%)  → +3.7%
scene0377: 42.2% (vs 基礎 38.3%)  → +3.9%
scene0258: 0.8% (vs 基礎 0.1%)    → +0.7% (極困難案例)
```

**限制**:
- ⚠️ 可能包含**少量背景**在角色周圍
- ⚠️ 對於**精細邊緣**要求高的場景可能過度

**建議使用情境**:
- ✅ LoRA 訓練 (需要完整角色)
- ✅ 角色聚類 (CLIP 需要足夠上下文)
- ✅ 大規模處理 (速度快)

---

### 擴張版本 (穩健選擇)

**優勢**:
1. ✅ **次高覆蓋率** 21.5%
2. ✅ **穩定性好** - 各圖片表現平衡
3. ✅ **速度快** 0.030s

**適合人群**:
- ✅ 希望**較完整但不過激**的分割
- ✅ 對邊緣質量有一定要求
- ✅ 需要穩定可預測的結果

---

### 其他配置分析

**Alpha Matting**:
- 與基礎版本幾乎相同
- 無明顯提升
- 不推薦

**平滑優先**:
- 覆蓋率與基礎相同
- 邊緣更平滑
- 適合需要平滑輪廓的場景

**保守版本 & 精細模式**:
- 覆蓋率最低 20.3%
- 更精確但可能遺漏部分
- 適合精細度優先的場景

---

## 🔬 個別圖片對比

### 高質量案例

**scene0065 (多角色場景)**:
| 配置 | 覆蓋率 | 提升 |
|------|--------|------|
| 基礎版本 | 40.0% | - |
| 擴張版本 | 41.6% | +1.6% |
| **激進版本** | **43.7%** | **+3.7%** ⭐ |

**scene0377 (雙角色)**:
| 配置 | 覆蓋率 | 提升 |
|------|--------|------|
| 基礎版本 | 38.3% | - |
| 擴張版本 | 39.9% | +1.6% |
| **激進版本** | **42.2%** | **+3.9%** ⭐ |

### 困難案例

**scene0471 (小角色)**:
| 配置 | 覆蓋率 | 提升 |
|------|--------|------|
| 基礎版本 | 4.6% | - |
| 擴張版本 | 5.4% | +0.8% |
| **激進版本** | **6.4%** | **+1.8%** ⭐ |

**scene0258 (極困難)**:
| 配置 | 覆蓋率 | 提升 |
|------|--------|------|
| 基礎版本 | 0.1% | - |
| 保守版本 | 0.0% | -0.1% ❌ |
| **激進版本** | **0.8%** | **+0.7%** ⭐ |

---

## 💡 實施建議

### 推薦方案: 採用「激進版本」

#### Step 1: 更新分割腳本

修改 `layered_segmentation_parallel.py` 的 `refine_mask` 函數:

```python
def refine_mask(mask: np.ndarray) -> np.ndarray:
    """優化版 mask 精煉 - 激進版本"""
    # Close operation - 強力填充小洞和連接斷裂
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=5)

    # 跳過 Open operation - 保留所有區域

    # 小範圍模糊 - 平滑但保留細節
    mask = cv2.GaussianBlur(mask, (3, 3), 0)

    # 低閾值 - 包含更多區域
    _, mask = cv2.threshold(mask, 100, 255, cv2.THRESH_BINARY)

    # 大範圍擴張 - 獲得完整輪廓
    dilate_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))
    mask = cv2.dilate(mask, dilate_kernel, iterations=3)

    return mask
```

#### Step 2: 測試優化版本

在小規模數據上測試:

```bash
conda run -n blip2-env python3 \
  scripts/tools/layered_segmentation_parallel.py \
  /home/b0979/yokai_input_fast/S1.01 \
  --output-dir /tmp/yokai_test_optimized \
  --num-workers 16 \
  --seg-model u2net \
  --inpaint-method telea
```

#### Step 3: 視覺檢查

查看優化結果:
```bash
# 當前測試結果位置
/mnt/c/AI_LLM_projects/ai_warehouse/outputs/u2net_optimization/image_*/激進版本/
```

每個圖片有三個文件:
- `mask.png` - 分割 mask
- `character.png` - 提取的角色 (RGBA)
- `overlay.jpg` - 原圖 + mask 疊加 (綠色)

#### Step 4: 如果滿意，全面部署

使用優化版本處理所有 frames:

```bash
# 修改後重新運行完整 pipeline
./scripts/batch/test_yokai_parallel.sh  # 先測試
./scripts/batch/run_yokai_parallel_full.sh  # 完整運行
```

---

## 📊 性能對比

### 處理速度

| 配置 | 單張時間 | 1M frames 預估 |
|------|----------|----------------|
| 基礎版本 (當前) | 0.067s | 19 小時 |
| **激進版本** | 0.031s | **9 小時** ⭐ |
| 擴張版本 | 0.030s | **8.5 小時** ⭐ |

**16 並行 workers**:
- 激進版本: **~34 分鐘** for 1M frames

---

## 🎯 最終建議

### 選擇建議

**優先推薦: 激進版本**

**理由**:
1. ✅ **最完整的角色提取** (+2.4% 覆蓋率)
2. ✅ **2倍速度提升** (0.067s → 0.031s)
3. ✅ **困難案例表現優異**
4. ✅ **適合 LoRA 訓練需求**

**如果追求穩健**: 擴張版本
- 較保守的提升
- 更平衡的表現
- 適合多數場景

**如果追求精細**: 精細模式
- 最精確的邊緣
- 但可能遺漏部分區域
- 適合高質量單圖處理

---

## 📁 測試數據位置

- **完整報告 JSON**: `/mnt/c/AI_LLM_projects/ai_warehouse/outputs/u2net_optimization/optimization_report.json`
- **視覺結果**: `/mnt/c/AI_LLM_projects/ai_warehouse/outputs/u2net_optimization/image_*/`
  - 每個圖片目錄包含 8 種配置的結果
  - 每種配置有 mask、character、overlay 三個文件
- **對比查看**: 可以直接用圖片查看器對比同一圖片的不同配置

---

## 🚀 下一步

1. ✅ **查看視覺結果** - 確認「激進版本」符合你的需求
2. ✅ **更新分割腳本** - 採用推薦的參數配置
3. ✅ **小規模測試** - 在 1-2 episodes 上驗證
4. ✅ **全面部署** - 使用優化版本處理所有 Yokai Watch frames

**預期改善**:
- ✅ 角色完整度提升 **~10-15%**
- ✅ 處理速度提升 **2倍**
- ✅ 更好的 LoRA 訓練質量

---

你想要我立即更新分割腳本使用「激進版本」配置嗎？或者你想先查看其他配置的視覺結果？
